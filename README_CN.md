# Graphor


## 描述

这是一个轻量的、通用的、渐进式的、可扩展组件的Web搭建器

可以通过系统内的可视化操作进行Web网页的开发，实现不需要使用代码或使用少量代码片段可进行Web网页开发

Github演示使用地址：<https://github-magneto.github.io/project-graph/react-web-ui/build>

可在演示地址中体验此项目搭建器，并参考下一章节的搭建器使用方法

想要本地跑项目，可以clone项目到本地，然后执行以下命令

    npm i && npm run start

## 搭建器使用方法

    提示：如果使用笔记本等小屏幕设备导致页面内容展示不全，可按住【Control】【-】来调小浏览器尺寸，获取更好的体验。

进入演示使用地址后，可以根据以下步骤进行尝试搭建

### 步骤一、添加组件至画布

在左侧导航栏中选择“Element Shop”，选择“Basic”类型中的“Input”组件，添加两个到画布中

### 步骤二、组件配置

在画布中，点击组件，在左侧出现的面板中，点击“Style Config”展开配置样式，点击“Property Config”展开属性配置

### 步骤三、移动组件

在左侧导航栏中选择“Element Overview”，可拖动条目进行移动组件

### 步骤四、绑定组件事件联动

选中第一个“Input”组件A，在左侧出现的面板中，点击“Event Config / Monitor”展开监听事件配置，添加一个事件，编辑添加的事件，“Monitor Key”选择“Set Value”（这意味着，组件A注册了一个事件监听，当这个监听被触发时会调用组件内的“Set Value”函数，即改变当前值）

选中第二个“Input”组件B，在左侧出现的面板中，点击“Event Config / Trigger”展开监听事件配置，添加一个事件，编辑添加的事件，“Trigger Key”选择“Value Change”，“Link Monitor Name”选择刚才添加的监听事件名称（这意味着，组件B注册了一个事件触发，当满足“Value Change”输入框内容变动时就会触发，触发会关联到所有当前选择的Monitor Name的监听事件中，即第一个组件A注册的监听事件中）

总结来说，组件的联动流程是这样的：用户在组件B中输入了一些内容 -> 触发了组件B的Trigger -> 组件B的Trigger通过Monitor Name关联到了组件A的Monitor，组件B将“Value Change”的输出传给了组件A的Monitor-> 组件A中的Monitor被触发，接受了传入值，并被作用于“Set Value” -> 视图中的组件A被设置了相同的内容

（其中，“Monitor Key”的“Set Value”、“Trigger Key”的“Value Change”，都是开发组件的时候内置的一些Key，在搭建器中的使用这些Key的时候，会自动调用组件内设置的一些逻辑，如果当前key无法满足组件的变动，可以使用Eval进行更细节的操作，选择“Monitor Type”、“Trigger Type”中的“Eval”可打开代码编辑器，可以在函数中进行编码）

### 步骤五、预览

通过前四步已经完成了视图和事件的加载，通过点击右上角的“Save”可以保存当前搭建至浏览器缓存，然后通过点击右上角的“Preview”可以在新打开的页面中预览打包发布后的页面情况，可以试着在第二个“Input”中输入一些内容看看

### 步骤六、发布

通过点击右上角的“Publish”可以下载当前搭建的Html文件

### 一般而言，操作的流程是这样的

1、选择合适的元素添加到画布

2、调整被添加的元素的属性，例如宽度、高度、背景色，不同的元素具有一些特定的属性，例如图像有链接属性，输入框有默认值属性

3、如果存在包含关系，则进行元素位置的操作（在本系统需进入元素预览进行元素的位移）

4、重复1、2、3步骤，直到完成视图的搭建

5、再完成视图后，需要完成逻辑相关的搭建，为每一个具有逻辑的元素，添加上合适的逻辑，例如点击事件，或者被其他元素at后的事件（在本系统中需在元素配置面板的事件配置完）






## 系统架构

### 项目的数据设计，整体思想是这样的

1、画布中渲染的样貌，是一份数据，这一份数据贯穿全项目，不仅仅在画布用到，同时也在元素预览中用到，同时在发布页面时也会用到

2、这一份数据以JSON的形式来存储，同时它的最外层type应该是Array类型，其中包含了多个Object，每一个Object是一个元素

3、通过添加元素，将一份新的Object添加到上述的Array中，然后画布就拿到了最新的Array

4、画布通过遍历的方式将Array转换为View，最终渲染到页面上

5、画布中已添加的元素，如果需要进行配置其属性值，则只需要修改其对应的Object中的属性即可

6、因为存在元素中包含元素的关系，所以Array是一个树级结构，即这样的结构

    [
      {
        ..., 
        children: [
          {...}, 
          {...}, 
        ]
      }
    ]

7、画布需要递归遍历渲染元素

......

### 元素的修改与渲染绑定设计，整体思路是这样的

1、每一个元素被添加后即形成了一份Object，其中包含了元素的属性、名称、Key等信息，存储在全局的Array中

2、这份Object将作为参数传到元素的 Render 和 Edit中

3、Render负责渲染View，根据参数传进来的Object渲染出不同的样貌

4、Edit负责修改Object，修改之后，Render就会渲染新的视图

5、搭建器负责将 Render 和 Edit 融合到搭建器内，画布渲染 Render，元素配置面板渲染 Edit

......

### 项目的发布设计，整体思路是这样的

1、发布页面以 一份HTML & 多份JS 形成，其中JS资源虽然为多份，但可以进行整合为一个JS文件，或者直接放入HTML script中

2、发布页面需要支持微前端部署，即将搭建的东西嵌入到其他应用中，所以需要支持发布后的JS包含DOM Render

3、JS资源包含几个部分：搭建数据（上述的Array，这份Array同时应用于搭建器和发布后的内容）、组件数据（与Array中应用到的组件相对应，包含了组件的渲染内容）、渲染JS（将Array结合组件转化为View的JS代码）、渲染到DOM（DOM Render，将View绑定到指定DOM）

4、发布的过程就是实现步骤三，将各种资源整合在一起，生成JS、生成HTML、将JS绑定到HTML里面，然后导出

......

### src-element目录概览

进入到 src-package，其中包含多个文件夹，分别对应了三个模块

element 元素模块，可在其中开发元素，用于搭建器中

main 核心模块，搭建器模块，搭建器的控制逻辑 操作逻辑 渲染逻辑 都在这里

publish 发布模块，搭建完毕后需要进行页面发布，相关功能在这里

example 这个可以忽略，用于存储搭建数据的缓存文件夹，没有实际作用


### 组件解析

1、license.js：包含元素的基础信息，Key标识符（每一个元素的Key唯一，用于渲染过程中的识别）、Dep（元素的依赖，如元素依赖某一个库，则搭建控制器将提前加载这一库）

2、information.js：包含元素的属性、名称、类型、事件、是否具有子元素

3、Render.jsx：元素的渲染，用于画布以及发布后页面的渲染，搭建器将根据这一文件进行渲染View，同时传入Object来渲染出想要的效果

4、Edit.jsx：元素的配置面板展示，用于在搭建器中配置元素的属性

5、View.jsx：元素在添加元素时的预览视图

上面的数据设计有提到每一个元素是一个Object的形式被添加到全局的Array中

这一份Object是通过传参的形式传入 Render.jsx & Edit.jsx 中，Render负责使用、Edit负责修改

以下是一个简单的伪代码，来讲解这一部分

    // Render.jsx

    function Render(props) {
      return props.data.text
    }

    // Edit.jsx

    function Edit(props) {
      return <input value={props.data.text} onchange={e => props.data.text = e.target.value}/>
    }

因为控制器的渲染更新策略，当Edit中有做修改元素的属性时，画布能够及时的拿到最新的数据，然后重新渲染最新的组件Render，从而在画布中渲染出最新的View